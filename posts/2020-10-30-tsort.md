---
title: 'magical shell utilities: tsort'
published: 2020-10-30
keywords: programming shell c linux
---

Graph theory comes up a lot more often than you think. You might be familiar with `sort` if you've done any work in the shell beyond `rm -rf /*`. `tsort` is a relative newcomer to the POSIX toolkit that lets you perform topological sorting on a directed acyclic graph. Well, it's new in the sense that it was only added to the standard in 2017. It's been around since 1979.

`tsort` reads a bunch of pairs of space-separated words from `stdin`, sorting them in topological order. For people unfamiliar with graph problems, a topological sort is taking a directed graph, then ordering the nodes as a 1-dimensional array. This corresponds to how you would traverse the graph in order. There's a really interesting Leetcode [problem](https://leetcode.com/problems/course-schedule-ii/description/) that involves graph traversal in this way. The prompt goes something like this:

You have a list of `n` courses you need to take, labeled from `0` to `n - 1`. Some courses have prerequisites that need to be satisfied before you can take them. Given `n`, and a list of pairs `[(a, b)]`, denoting that `a` is a prerequisite of `b`, return the order in which you need to take these courses.

So let's go with a simple example. We'll use part of my old university transcript.

```haskell
courses = [ (BIO120, HMB265)
          , (BCH210, BCH311)
          , (HMB312, HAJ453)
          , (BIO220, HAJ453)
          , (CHM136, BCH210)
          , (BIO130, PSL301)
          , (HMB265, HMB312)
          , (HMB204, HMB312)
          , (BIO120, BIO220)
          , (BIO130, HMB265)
          ]
```

Where do we go with this? How the hell do I graduate if my course schedule is a complete mess? (In real life, there are credit requirements, corequisites and sometimes prerequisite requirements aren't actually mandatory, but we'll assume a simple dependency graph here.)

It's a small enough example that we can immediately see which courses aren't dependent on others. `BIO120, BIO130, ` and `CHM136` are first-year courses, so it makes sense that we can put them in order them first. (`CHM136` actually required `CHM135`, which sucked). We can reshuffle this list a bit by hand now.

```haskell
courses = [ (BIO120, HMB265) -- *
          , (BIO120, BIO220) -- *
          , (BIO130, HMB204) -- *
          , (BIO130, HMB265) -- *
          , (BIO130, PSL301) -- *
          , (CHM136, BCH210) -- *
          , (BCH210, BCH311)
          , (HMB312, HAJ453)
          , (BIO220, HAJ453)
          , (HMB265, HMB312)
          , (HMB204, HMB312)
          ]
`
```

If we look at these courses as nodes, we know that they don't have any incoming edges from other nodes. In our context, they're courses that can be taken immediately without having to worry about the registrar kicking you out halfway through the semester. 

Now what? It seems like `BCH210` requires CHM136, so we would have to take it one semester afterwards. Same goes for `HMB265, BIO220, HMB204,` and `PSL301`. Let's assume that we somehow managed to bumble our way through 6 required courses in one semester. They're done. We don't care about them anymore, and they're on our transcript.

``` haskell
transcript = [ BIO120
             , BIO130
             , CHM136
             ]
   
```

We can remove these completed courses from our graph. Let's take a short break and refresh ourselves on what our course graph looks like now. Let's reformat the course requirements in a different way, by looking at **incoming** edges instead of **outgoing**.

```haskell
courseRequirements = {
  HMB265: [],
  BIO220: [],
  HMB204: [],
  PSL301: [],
  BCH210: [],
  BCH311: [BCH210],
  HAJ453: [HMB312, BIO220]
  HMB312: [HMB204]
}
```

Nice! We've finished all the requirements for 5 courses! It's pretty clear what our next semester is gonna to look like. After our second semester, our transcript looks like this now:
```haskell
transcript = [ BIO120
             , BIO130
             , CHM136
              -- second semester
             , HMB265
             , BIO220
             , HMB204
             , PSL301
             , BCH210
             ]
```

Are we done yet? Nope. Looking back at `courseRequirements`, `HAJ453` looks like our final boss. Let's reorder our requirements list again.
```haskell
courseRequirements = {
  BCH311: [],
  HMB312: []
  HAJ453: [HMB312]
}
```

We take `BCH311` and `HMB312` next, before we can do a victory lap through our senior year in `HAJ453`. Yadda yadda yadda. In total, it took us 4 iterations to go from being clueless freshmen to becoming well-respected biologists. 

Do you see the pattern in our strategy? We used [Kahn's algorithm](https://dl.acm.org/doi/10.1145/368996.369025) for topological sorting. We started off with a random list of elements `(a, b)`, where `a` has to be fulfilled before `b`. We identified our freshmen courses (nodes with no incoming edges), and picked them off one-by-one knowing we would be safe in fulfilling them. We keep doing this until we're out of courses to take, and the University shoves a diploma in our hands and cancels our health insurance. 

This sucks to figure out by hand, and we're only dealing with 11 courses. What about 40? (I really hate U of T's degree explorer.) What if we're immortal, and trying to take every single course at the University? We need computers - let's express this in their language.

```python
def gradPlan(preReqs):
    transcript = []

    dependencies = defaultdict(set)

    for (prereq, course) in preReqs:
        dependencies[course].add(prereq)

    eligibleCourses = 
        list(
            filter(lambda course: not dependencies[course], dependencies)
            )

    while eligibleCourses:
        current = eligibleCourses.pop() # just take any arbitrary course with no unfulfilled prereqs
        transcript.append(current) # add that to our transcript

        #  now that we've taken the class, see if we can take any more courses now
        nextCourses = filter(lambda course: current in dependencies[course], dependencies)
        for nxt in nextCourses:
            dependencies[nxt].discard(current)
            # since we've fulfilled current
            if not dependencies[nxt]:
                eligibleCourses.append(nxt)
    
    return transcript
```

This is pretty much pseudoPython, but I think it illustrates the algorithm pretty well. At any point in time, we can only take courses that we're eligible to enroll in. The relative order of courses doesn't matter if they're at the same "depth" within the graph. For instance, we can take `BIO120` at the same time as `CHM136` since they both start off without any prerequisite courses, so it doesn't matter which comes first in our transcript. For courses that directly depend on these, however, we can only take them after we're finished. How are you supposed to know understand glycolysis if you don't even know what electrons are?

A surprisingly huge amount of problems can be reduced to simple graph traversal. Every time you order your compiler to build your spaghetti projects, that mess of function calls has to be sorted in order for the linker to figure out where your code actually jumps to. Even well-organized projects will have their functions compartmentalized into separate modules. This makes it easier for the programmer to reason about how their code fits together, but creates a difficult challenge for the compiler to figure out. 

<p style="text-align:center"><img src="/images/yesbabe.png" alt="Yes honey..." style="margin: 0 auto; width: 50%; height: auto;"></p>

todo: talk about how the linker inlines return and function call addresses
```bash
$ cat tsort.txt
explode think
cowboy laugh
ahegao explode
ahegao sunglasses
laugh sunglasses
explode cowboy
ahegao cowboy

$ `sort < tsort.txt
ahegao
explode
cowboy
think
laugh
sunglasses

```

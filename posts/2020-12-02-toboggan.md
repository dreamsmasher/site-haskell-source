---
title: "advent of code 2020: lazy tobogganing"
published: 2020-12-02
last: 2020-12-02
author: Norman Liu
keywords: haskell programming advent 
---

It's December, so you know what that means.

Debt? Maybe. Alcoholism? No time. Time to save Santa again? Yep.

[Advent of Code](https://adventofcode.com) is finally back, and so everybody's in full motion trying to contort their favourite languages into workable problem-solving tools, me included. I've been a huge fan of Advent of Code ever since I started programming, and I love going back and working on old problems when Leetcode and Codewars get boring. I'm hoping for some problems spread out over several days that involve incremental and visible progress, like last year's [Intcode computer](https://adventofcode.com/2019/day/2).

Today's problem is relatively simple - even though you've travelled through [space](https://adventofcode.com/2019/day/1), [time](https://adventofcode.com/2018/day/1), and into [Santa's computer](https://adventofcode.com/2017/day/1), you still rely on sled-based transportation to get to the airport. This is a task fraught with danger, because trees litter the landscape more than potholes mark the 401. Given a map of the area and two integers denoting rise and run, your task is to figure out how many trees you'll collide with on your path.

```haskell
example :: [Char]
example = "
  ..##.......
  #...#...#..
  .#....#..#.
  ..#.#...#.#
  .#...##..#.
  ..#.##.....
  .#.#.#....#
  .#........#
  #.##...#...
  #...##....#
  .#..#...#.#
  "
```
`#`'s represent trees and `.`'s are empty land. Mercifully, we won't need to deal with floating-point calculations for this problem.

The landscape repeats itself horizontally, so running off the right side of the map will just put you back where you started. Starting from the top left of the map and a rise and run of `(3, 1)`, how many trees will we collide with?

Let's start off by making our problem a little easier. We can't directly add booleans in Haskell, and binary looks way cleaner anyways. `cycle` takes a list and loops it in itself, creating an infinite generator.

``` haskell
import Control.Arrow
import Control.Applicative
import Data.List.Split
import Data.Function

inp2Int :: [Char] -> [[Int]]
inp2Int = lines >>> fmap (cycle . fmap (\c -> ((c == '.') ? 0 $ 1)))
```


"Wait, Haskell doesn't have ternary operators?" you say, bound to the shackles of built-in syntax.

```haskell
(?) :: Bool -> a -> a -> a
(?) True = const
(?) _ = const id
```

If you were writing this in a language where space matters, you might implement the rollover function using bit rotation. Lazy lists are more fun.

``` haskell
slide :: Int -> [[a]] -> [[a]]
slide run = (iterate (fmap (drop run) >>> tail) >>= zipWith const) >>> fmap head
```

We can just walk down our list of infinite rows, dropping the first `run` elements of each stream at every turn. It's not *too* efficient for gigantic inputs, but it's elegant. We take a list, repeatedly mapping `drop run` over it, and stepping down to the next stream. Using the `Monad` instance for functions (aka the `Reader` monad), we can take advantage of the fact that `iterate (fmap (drop run) >>> tail)` is a single-argument function, and `zipWith const` takes two arguments. This fulfills the `m a -> (a -> m b) -> m b` requirement for monadic binding, and so we can apply them to the same input without having to pollute our code with cruft. Can you imagine **actually** naming arguments?

``` haskell
instance Monad ((->) r) where
  return = const
  x >>= f = \r -> f (x r) r
```

You can do the same thing with `liftA2 f x id`, but that's less concise and you can't show off your monad wizardry. This might seem like dangerous code, as `iterate` doesn't stop applying its given transformation, and `tail` is a partial function. Usually, you would incur a runtime error from taking the tail of an empty list, but that's fine. `zipWith` is bounded to the length of the shorter input list, and so we consume exactly as many inputs from `iterate` as there are in the original list. Any more, and Haskell would crash on us. It's still arguably less dangerous than crashing into trees.

A more intuitive version of `slide` might look like

``` haskell
meander :: Int -> [[a]] -> [[a]]
meander _ [] = []
meander run (x:xs) = x : meander run (drop run <$> xs)
```

Let's try it out.

```haskell
> slide 1 [[1,2,3],[4,5,6],[7,8,9]]
[[1,2,3],[5,6],[9]]

> map (take 8) $ slide 1 (map cycle [[1..5], [11..15], [21..25]])
[
  [1,2,3,4,5,1,2,3],
  [12,13,14,15,11,12,13,14],
  [23,24,25,21,22,23,24,25]
]
```

We've basically solved the problem at this point. We've figured out how to model stepping forward, and all that remains is to chain these functions together. Recall that the prompt is asking us to output the amount of trees that we have the misfortune of encountering on our journey, and so:

``` haskell
toboggan :: [[Int]] -> Int -> Int -> Int   
toboggan xs run rise = xs & (chunksOf rise >>> map head >>> slide run >>> map head >>> sum)
```
I've recently started using arrows to compose functions from left-to-right, and I'm loving the readability of my code now. The reason why our arguments are backwards will become apparent in the second part of the problem. In the meantime though, we've done it!

``` haskell
day3Pt1 :: [Char] -> Int
day3Pt1 = inp2Int >>> flip (flip toboggan 3) 1

> day3Pt1 example
176
```
Infinite lists are magical when you don't have to consume them in their entirety.

[Part 2 writeup to come soon!]
